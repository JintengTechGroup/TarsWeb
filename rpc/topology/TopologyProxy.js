// **********************************************************************
// Parsed By TarsParser(2.4.5), Generated By tars2node(20200707)
// TarsParser Maintained By <TARS> and tars2node Maintained By <superzheng>
// Generated from "Topology.tars" by Client Mode
// **********************************************************************

/* eslint-disable */

"use strict";

var assert    = require("assert");
var TarsStream = require("@tars/stream");
var TarsError  = require("@tars/rpc").error;

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _makeError = function (data, message, type) {
    var error = new Error(message || "");
    error.request = data.request;
    error.response = {
        "costtime" : data.request.costtime
    };
    if (type === TarsError.CLIENT.DECODE_ERROR) {
        error.name = "DECODE_ERROR";
        error.response.error = {
            "code" : type,
            "message" : message
        };
    } else {
        error.name = "RPC_ERROR";
        error.response.error = data.error;
    }
    return error;
};

var tars = tars || {};
module.exports.tars = tars;

tars.TopologyProxy = function () {
    this._name    = undefined;
    this._worker  = undefined;
};

tars.TopologyProxy.prototype.setTimeout = function (iTimeout) {
    this._worker.timeout = iTimeout;
};

tars.TopologyProxy.prototype.getTimeout = function () {
    return this._worker.timeout;
};

tars.TopologyProxy.prototype.setVersion = function (iVersion) {
    this._worker.version = iVersion;
};

tars.TopologyProxy.prototype.getVersion = function () {
    return this._worker.version;
};

tars.Vertex = function() {
    this.vertex = "";
    this.callCount = 0;
    this.callTime = 0;
    this._classname = "tars.Vertex";
};
tars.Vertex._classname = "tars.Vertex";
tars.Vertex._write = function (os, tag, value) { os.writeStruct(tag, value); };
tars.Vertex._read  = function (is, tag, def) { return is.readStruct(tag, true, def); };
tars.Vertex._readFrom = function (is) {
    var tmp = new tars.Vertex;
    tmp.vertex = is.readString(0, true, "");
    tmp.callCount = is.readInt64(1, true, 0);
    tmp.callTime = is.readInt64(2, true, 0);
    return tmp;
};
tars.Vertex.prototype._writeTo = function (os) {
    os.writeString(0, this.vertex);
    os.writeInt64(1, this.callCount);
    os.writeInt64(2, this.callTime);
};
tars.Vertex.prototype._equal = function () {
    assert.fail("this structure not define key operation");
};
tars.Vertex.prototype._genKey = function () {
    if (!this._proto_struct_name_) {
        this._proto_struct_name_ = "STRUCT" + Math.random();
    }
    return this._proto_struct_name_;
};
tars.Vertex.prototype.toObject = function() { 
    return {
        "vertex" : this.vertex,
        "callCount" : this.callCount,
        "callTime" : this.callTime
    };
};
tars.Vertex.prototype.readFromObject = function(json) { 
    _hasOwnProperty.call(json, "vertex") && (this.vertex = json.vertex);
    _hasOwnProperty.call(json, "callCount") && (this.callCount = json.callCount);
    _hasOwnProperty.call(json, "callTime") && (this.callTime = json.callTime);
    return this;
};
tars.Vertex.prototype.toBinBuffer = function () {
    var os = new TarsStream.TarsOutputStream();
    this._writeTo(os);
    return os.getBinBuffer();
};
tars.Vertex.new = function () {
    return new tars.Vertex();
};
tars.Vertex.create = function (is) {
    return tars.Vertex._readFrom(is);
};

tars.Edge = function() {
    this.fromVertex = "";
    this.toVertex = "";
    this.callCount = 0;
    this.callTime = 0;
    this.spanId = "";
    this.csTime = 0;
    this.srTime = 0;
    this.ssTime = 0;
    this.crTime = 0;
    this.csData = "";
    this.srData = "";
    this.ssData = "";
    this.crData = "";
    this.ret = "";
    this._classname = "tars.Edge";
};
tars.Edge._classname = "tars.Edge";
tars.Edge._write = function (os, tag, value) { os.writeStruct(tag, value); };
tars.Edge._read  = function (is, tag, def) { return is.readStruct(tag, true, def); };
tars.Edge._readFrom = function (is) {
    var tmp = new tars.Edge;
    tmp.fromVertex = is.readString(0, true, "");
    tmp.toVertex = is.readString(1, true, "");
    tmp.callCount = is.readInt64(2, true, 0);
    tmp.callTime = is.readInt64(3, true, 0);
    tmp.spanId = is.readString(4, true, "");
    tmp.csTime = is.readInt64(5, true, 0);
    tmp.srTime = is.readInt64(6, true, 0);
    tmp.ssTime = is.readInt64(7, true, 0);
    tmp.crTime = is.readInt64(8, true, 0);
    tmp.csData = is.readString(9, true, "");
    tmp.srData = is.readString(10, true, "");
    tmp.ssData = is.readString(11, true, "");
    tmp.crData = is.readString(12, true, "");
    tmp.ret = is.readString(13, true, "");
    return tmp;
};
tars.Edge.prototype._writeTo = function (os) {
    os.writeString(0, this.fromVertex);
    os.writeString(1, this.toVertex);
    os.writeInt64(2, this.callCount);
    os.writeInt64(3, this.callTime);
    os.writeString(4, this.spanId);
    os.writeInt64(5, this.csTime);
    os.writeInt64(6, this.srTime);
    os.writeInt64(7, this.ssTime);
    os.writeInt64(8, this.crTime);
    os.writeString(9, this.csData);
    os.writeString(10, this.srData);
    os.writeString(11, this.ssData);
    os.writeString(12, this.crData);
    os.writeString(13, this.ret);
};
tars.Edge.prototype._equal = function () {
    assert.fail("this structure not define key operation");
};
tars.Edge.prototype._genKey = function () {
    if (!this._proto_struct_name_) {
        this._proto_struct_name_ = "STRUCT" + Math.random();
    }
    return this._proto_struct_name_;
};
tars.Edge.prototype.toObject = function() { 
    return {
        "fromVertex" : this.fromVertex,
        "toVertex" : this.toVertex,
        "callCount" : this.callCount,
        "callTime" : this.callTime,
        "spanId" : this.spanId,
        "csTime" : this.csTime,
        "srTime" : this.srTime,
        "ssTime" : this.ssTime,
        "crTime" : this.crTime,
        "csData" : this.csData,
        "srData" : this.srData,
        "ssData" : this.ssData,
        "crData" : this.crData,
        "ret" : this.ret
    };
};
tars.Edge.prototype.readFromObject = function(json) { 
    _hasOwnProperty.call(json, "fromVertex") && (this.fromVertex = json.fromVertex);
    _hasOwnProperty.call(json, "toVertex") && (this.toVertex = json.toVertex);
    _hasOwnProperty.call(json, "callCount") && (this.callCount = json.callCount);
    _hasOwnProperty.call(json, "callTime") && (this.callTime = json.callTime);
    _hasOwnProperty.call(json, "spanId") && (this.spanId = json.spanId);
    _hasOwnProperty.call(json, "csTime") && (this.csTime = json.csTime);
    _hasOwnProperty.call(json, "srTime") && (this.srTime = json.srTime);
    _hasOwnProperty.call(json, "ssTime") && (this.ssTime = json.ssTime);
    _hasOwnProperty.call(json, "crTime") && (this.crTime = json.crTime);
    _hasOwnProperty.call(json, "csData") && (this.csData = json.csData);
    _hasOwnProperty.call(json, "srData") && (this.srData = json.srData);
    _hasOwnProperty.call(json, "ssData") && (this.ssData = json.ssData);
    _hasOwnProperty.call(json, "crData") && (this.crData = json.crData);
    _hasOwnProperty.call(json, "ret") && (this.ret = json.ret);
    return this;
};
tars.Edge.prototype.toBinBuffer = function () {
    var os = new TarsStream.TarsOutputStream();
    this._writeTo(os);
    return os.getBinBuffer();
};
tars.Edge.new = function () {
    return new tars.Edge();
};
tars.Edge.create = function (is) {
    return tars.Edge._readFrom(is);
};

tars.Graph = function() {
    this.vs = new TarsStream.List(tars.Vertex);
    this.es = new TarsStream.List(tars.Edge);
    this._classname = "tars.Graph";
};
tars.Graph._classname = "tars.Graph";
tars.Graph._write = function (os, tag, value) { os.writeStruct(tag, value); };
tars.Graph._read  = function (is, tag, def) { return is.readStruct(tag, true, def); };
tars.Graph._readFrom = function (is) {
    var tmp = new tars.Graph;
    tmp.vs = is.readList(0, true, TarsStream.List(tars.Vertex));
    tmp.es = is.readList(1, true, TarsStream.List(tars.Edge));
    return tmp;
};
tars.Graph.prototype._writeTo = function (os) {
    os.writeList(0, this.vs);
    os.writeList(1, this.es);
};
tars.Graph.prototype._equal = function () {
    assert.fail("this structure not define key operation");
};
tars.Graph.prototype._genKey = function () {
    if (!this._proto_struct_name_) {
        this._proto_struct_name_ = "STRUCT" + Math.random();
    }
    return this._proto_struct_name_;
};
tars.Graph.prototype.toObject = function() { 
    return {
        "vs" : this.vs.toObject(),
        "es" : this.es.toObject()
    };
};
tars.Graph.prototype.readFromObject = function(json) { 
    _hasOwnProperty.call(json, "vs") && (this.vs.readFromObject(json.vs));
    _hasOwnProperty.call(json, "es") && (this.es.readFromObject(json.es));
    return this;
};
tars.Graph.prototype.toBinBuffer = function () {
    var os = new TarsStream.TarsOutputStream();
    this._writeTo(os);
    return os.getBinBuffer();
};
tars.Graph.new = function () {
    return new tars.Graph();
};
tars.Graph.create = function (is) {
    return tars.Graph._readFrom(is);
};

tars.Summary = function() {
    this.name = "";
    this.startTime = 0;
    this.endTime = 0;
    this._classname = "tars.Summary";
};
tars.Summary._classname = "tars.Summary";
tars.Summary._write = function (os, tag, value) { os.writeStruct(tag, value); };
tars.Summary._read  = function (is, tag, def) { return is.readStruct(tag, true, def); };
tars.Summary._readFrom = function (is) {
    var tmp = new tars.Summary;
    tmp.name = is.readString(0, true, "");
    tmp.startTime = is.readInt64(1, true, 0);
    tmp.endTime = is.readInt64(2, true, 0);
    return tmp;
};
tars.Summary.prototype._writeTo = function (os) {
    os.writeString(0, this.name);
    os.writeInt64(1, this.startTime);
    os.writeInt64(2, this.endTime);
};
tars.Summary.prototype._equal = function () {
    assert.fail("this structure not define key operation");
};
tars.Summary.prototype._genKey = function () {
    if (!this._proto_struct_name_) {
        this._proto_struct_name_ = "STRUCT" + Math.random();
    }
    return this._proto_struct_name_;
};
tars.Summary.prototype.toObject = function() { 
    return {
        "name" : this.name,
        "startTime" : this.startTime,
        "endTime" : this.endTime
    };
};
tars.Summary.prototype.readFromObject = function(json) { 
    _hasOwnProperty.call(json, "name") && (this.name = json.name);
    _hasOwnProperty.call(json, "startTime") && (this.startTime = json.startTime);
    _hasOwnProperty.call(json, "endTime") && (this.endTime = json.endTime);
    return this;
};
tars.Summary.prototype.toBinBuffer = function () {
    var os = new TarsStream.TarsOutputStream();
    this._writeTo(os);
    return os.getBinBuffer();
};
tars.Summary.new = function () {
    return new tars.Summary();
};
tars.Summary.create = function (is) {
    return tars.Summary._readFrom(is);
};

var __tars_Topology$graphFunction$IF = {
    "name" : "graphFunction",
    "return" : "int32",
    "arguments" : [{
        "name" : "date",
        "class" : "string",
        "direction" : "in"
    }, {
        "name" : "functionName",
        "class" : "string",
        "direction" : "in"
    }, {
        "name" : "graph",
        "class" : "list(tars.Graph)",
        "direction" : "out"
    }]
};

var __tars_Topology$graphFunction$IE = function (date, functionName) {
    var os = new TarsStream.TarsOutputStream();
    os.writeString(1, date);
    os.writeString(2, functionName);
    return os.getBinBuffer();
};

var __tars_Topology$graphFunction$ID = function (data) {
    try {
        var is = new TarsStream.TarsInputStream(data.response.sBuffer);
        return {
            "request" : data.request,
            "response" : {
                "costtime" : data.request.costtime,
                "return" : is.readInt32(0, true, 0),
                "arguments" : {
                    "graph" : is.readList(3, true, TarsStream.List(tars.Graph))
                }
            }
        };
    } catch (e) {
        throw _makeError(data, e.message, TarsError.CLIENT.DECODE_ERROR);
    }
};

var __tars_Topology$graphFunction$PE = function (date, functionName, __$PROTOCOL$VERSION) {
    var tup = new TarsStream.UniAttribute();
    tup.tupVersion = __$PROTOCOL$VERSION;
    tup.writeString("date", date);
    tup.writeString("functionName", functionName);
    return tup;
};

var __tars_Topology$graphFunction$PD = function (data) {
    try {
        var tup = data.response.tup;
        return {
            "request" : data.request,
            "response" : {
                "costtime" : data.request.costtime,
                "return" : tup.readInt32("", 0),
                "arguments" : {
                    "graph" : tup.readList("graph", TarsStream.List(tars.Graph))
                }
            }
        };
    } catch (e) {
        throw _makeError(data, e.message, TarsError.CLIENT.DECODE_ERROR);
    }
};

var __tars_Topology$graphFunction$ER = function (data) {
    throw _makeError(data, "Call Topology::graphFunction failed");
};

tars.TopologyProxy.prototype.graphFunction = function (date, functionName) {
    var version = this._worker.version;
    if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
        return this._worker.tup_invoke("graphFunction", __tars_Topology$graphFunction$PE(date, functionName, version), arguments[arguments.length - 1], __tars_Topology$graphFunction$IF).then(__tars_Topology$graphFunction$PD, __tars_Topology$graphFunction$ER);
    } else {
        return this._worker.tars_invoke("graphFunction", __tars_Topology$graphFunction$IE(date, functionName), arguments[arguments.length - 1], __tars_Topology$graphFunction$IF).then(__tars_Topology$graphFunction$ID, __tars_Topology$graphFunction$ER);
    }
};
tars.TopologyProxy.graphFunction = __tars_Topology$graphFunction$IF;

var __tars_Topology$graphServer$IF = {
    "name" : "graphServer",
    "return" : "int32",
    "arguments" : [{
        "name" : "date",
        "class" : "string",
        "direction" : "in"
    }, {
        "name" : "serverName",
        "class" : "string",
        "direction" : "in"
    }, {
        "name" : "graph",
        "class" : "list(tars.Graph)",
        "direction" : "out"
    }]
};

var __tars_Topology$graphServer$IE = function (date, serverName) {
    var os = new TarsStream.TarsOutputStream();
    os.writeString(1, date);
    os.writeString(2, serverName);
    return os.getBinBuffer();
};

var __tars_Topology$graphServer$ID = function (data) {
    try {
        var is = new TarsStream.TarsInputStream(data.response.sBuffer);
        return {
            "request" : data.request,
            "response" : {
                "costtime" : data.request.costtime,
                "return" : is.readInt32(0, true, 0),
                "arguments" : {
                    "graph" : is.readList(3, true, TarsStream.List(tars.Graph))
                }
            }
        };
    } catch (e) {
        throw _makeError(data, e.message, TarsError.CLIENT.DECODE_ERROR);
    }
};

var __tars_Topology$graphServer$PE = function (date, serverName, __$PROTOCOL$VERSION) {
    var tup = new TarsStream.UniAttribute();
    tup.tupVersion = __$PROTOCOL$VERSION;
    tup.writeString("date", date);
    tup.writeString("serverName", serverName);
    return tup;
};

var __tars_Topology$graphServer$PD = function (data) {
    try {
        var tup = data.response.tup;
        return {
            "request" : data.request,
            "response" : {
                "costtime" : data.request.costtime,
                "return" : tup.readInt32("", 0),
                "arguments" : {
                    "graph" : tup.readList("graph", TarsStream.List(tars.Graph))
                }
            }
        };
    } catch (e) {
        throw _makeError(data, e.message, TarsError.CLIENT.DECODE_ERROR);
    }
};

var __tars_Topology$graphServer$ER = function (data) {
    throw _makeError(data, "Call Topology::graphServer failed");
};

tars.TopologyProxy.prototype.graphServer = function (date, serverName) {
    var version = this._worker.version;
    if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
        return this._worker.tup_invoke("graphServer", __tars_Topology$graphServer$PE(date, serverName, version), arguments[arguments.length - 1], __tars_Topology$graphServer$IF).then(__tars_Topology$graphServer$PD, __tars_Topology$graphServer$ER);
    } else {
        return this._worker.tars_invoke("graphServer", __tars_Topology$graphServer$IE(date, serverName), arguments[arguments.length - 1], __tars_Topology$graphServer$IF).then(__tars_Topology$graphServer$ID, __tars_Topology$graphServer$ER);
    }
};
tars.TopologyProxy.graphServer = __tars_Topology$graphServer$IF;

var __tars_Topology$graphTrace$IF = {
    "name" : "graphTrace",
    "return" : "int32",
    "arguments" : [{
        "name" : "date",
        "class" : "string",
        "direction" : "in"
    }, {
        "name" : "traceId",
        "class" : "string",
        "direction" : "in"
    }, {
        "name" : "graph",
        "class" : "tars.Graph",
        "direction" : "out"
    }]
};

var __tars_Topology$graphTrace$IE = function (date, traceId) {
    var os = new TarsStream.TarsOutputStream();
    os.writeString(1, date);
    os.writeString(2, traceId);
    return os.getBinBuffer();
};

var __tars_Topology$graphTrace$ID = function (data) {
    try {
        var is = new TarsStream.TarsInputStream(data.response.sBuffer);
        return {
            "request" : data.request,
            "response" : {
                "costtime" : data.request.costtime,
                "return" : is.readInt32(0, true, 0),
                "arguments" : {
                    "graph" : is.readStruct(3, true, tars.Graph)
                }
            }
        };
    } catch (e) {
        throw _makeError(data, e.message, TarsError.CLIENT.DECODE_ERROR);
    }
};

var __tars_Topology$graphTrace$PE = function (date, traceId, __$PROTOCOL$VERSION) {
    var tup = new TarsStream.UniAttribute();
    tup.tupVersion = __$PROTOCOL$VERSION;
    tup.writeString("date", date);
    tup.writeString("traceId", traceId);
    return tup;
};

var __tars_Topology$graphTrace$PD = function (data) {
    try {
        var tup = data.response.tup;
        return {
            "request" : data.request,
            "response" : {
                "costtime" : data.request.costtime,
                "return" : tup.readInt32("", 0),
                "arguments" : {
                    "graph" : tup.readStruct("graph", tars.Graph)
                }
            }
        };
    } catch (e) {
        throw _makeError(data, e.message, TarsError.CLIENT.DECODE_ERROR);
    }
};

var __tars_Topology$graphTrace$ER = function (data) {
    throw _makeError(data, "Call Topology::graphTrace failed");
};

tars.TopologyProxy.prototype.graphTrace = function (date, traceId) {
    var version = this._worker.version;
    if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
        return this._worker.tup_invoke("graphTrace", __tars_Topology$graphTrace$PE(date, traceId, version), arguments[arguments.length - 1], __tars_Topology$graphTrace$IF).then(__tars_Topology$graphTrace$PD, __tars_Topology$graphTrace$ER);
    } else {
        return this._worker.tars_invoke("graphTrace", __tars_Topology$graphTrace$IE(date, traceId), arguments[arguments.length - 1], __tars_Topology$graphTrace$IF).then(__tars_Topology$graphTrace$ID, __tars_Topology$graphTrace$ER);
    }
};
tars.TopologyProxy.graphTrace = __tars_Topology$graphTrace$IF;

var __tars_Topology$listFunction$IF = {
    "name" : "listFunction",
    "return" : "int32",
    "arguments" : [{
        "name" : "date",
        "class" : "string",
        "direction" : "in"
    }, {
        "name" : "serverName",
        "class" : "string",
        "direction" : "in"
    }, {
        "name" : "fs",
        "class" : "list(string)",
        "direction" : "out"
    }]
};

var __tars_Topology$listFunction$IE = function (date, serverName) {
    var os = new TarsStream.TarsOutputStream();
    os.writeString(1, date);
    os.writeString(2, serverName);
    return os.getBinBuffer();
};

var __tars_Topology$listFunction$ID = function (data) {
    try {
        var is = new TarsStream.TarsInputStream(data.response.sBuffer);
        return {
            "request" : data.request,
            "response" : {
                "costtime" : data.request.costtime,
                "return" : is.readInt32(0, true, 0),
                "arguments" : {
                    "fs" : is.readList(3, true, TarsStream.List(TarsStream.String))
                }
            }
        };
    } catch (e) {
        throw _makeError(data, e.message, TarsError.CLIENT.DECODE_ERROR);
    }
};

var __tars_Topology$listFunction$PE = function (date, serverName, __$PROTOCOL$VERSION) {
    var tup = new TarsStream.UniAttribute();
    tup.tupVersion = __$PROTOCOL$VERSION;
    tup.writeString("date", date);
    tup.writeString("serverName", serverName);
    return tup;
};

var __tars_Topology$listFunction$PD = function (data) {
    try {
        var tup = data.response.tup;
        return {
            "request" : data.request,
            "response" : {
                "costtime" : data.request.costtime,
                "return" : tup.readInt32("", 0),
                "arguments" : {
                    "fs" : tup.readList("fs", TarsStream.List(TarsStream.String))
                }
            }
        };
    } catch (e) {
        throw _makeError(data, e.message, TarsError.CLIENT.DECODE_ERROR);
    }
};

var __tars_Topology$listFunction$ER = function (data) {
    throw _makeError(data, "Call Topology::listFunction failed");
};

tars.TopologyProxy.prototype.listFunction = function (date, serverName) {
    var version = this._worker.version;
    if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
        return this._worker.tup_invoke("listFunction", __tars_Topology$listFunction$PE(date, serverName, version), arguments[arguments.length - 1], __tars_Topology$listFunction$IF).then(__tars_Topology$listFunction$PD, __tars_Topology$listFunction$ER);
    } else {
        return this._worker.tars_invoke("listFunction", __tars_Topology$listFunction$IE(date, serverName), arguments[arguments.length - 1], __tars_Topology$listFunction$IF).then(__tars_Topology$listFunction$ID, __tars_Topology$listFunction$ER);
    }
};
tars.TopologyProxy.listFunction = __tars_Topology$listFunction$IF;

var __tars_Topology$listTrace$IF = {
    "name" : "listTrace",
    "return" : "int32",
    "arguments" : [{
        "name" : "date",
        "class" : "string",
        "direction" : "in"
    }, {
        "name" : "serverName",
        "class" : "string",
        "direction" : "in"
    }, {
        "name" : "ts",
        "class" : "list(string)",
        "direction" : "out"
    }]
};

var __tars_Topology$listTrace$IE = function (date, serverName) {
    var os = new TarsStream.TarsOutputStream();
    os.writeString(1, date);
    os.writeString(2, serverName);
    return os.getBinBuffer();
};

var __tars_Topology$listTrace$ID = function (data) {
    try {
        var is = new TarsStream.TarsInputStream(data.response.sBuffer);
        return {
            "request" : data.request,
            "response" : {
                "costtime" : data.request.costtime,
                "return" : is.readInt32(0, true, 0),
                "arguments" : {
                    "ts" : is.readList(3, true, TarsStream.List(TarsStream.String))
                }
            }
        };
    } catch (e) {
        throw _makeError(data, e.message, TarsError.CLIENT.DECODE_ERROR);
    }
};

var __tars_Topology$listTrace$PE = function (date, serverName, __$PROTOCOL$VERSION) {
    var tup = new TarsStream.UniAttribute();
    tup.tupVersion = __$PROTOCOL$VERSION;
    tup.writeString("date", date);
    tup.writeString("serverName", serverName);
    return tup;
};

var __tars_Topology$listTrace$PD = function (data) {
    try {
        var tup = data.response.tup;
        return {
            "request" : data.request,
            "response" : {
                "costtime" : data.request.costtime,
                "return" : tup.readInt32("", 0),
                "arguments" : {
                    "ts" : tup.readList("ts", TarsStream.List(TarsStream.String))
                }
            }
        };
    } catch (e) {
        throw _makeError(data, e.message, TarsError.CLIENT.DECODE_ERROR);
    }
};

var __tars_Topology$listTrace$ER = function (data) {
    throw _makeError(data, "Call Topology::listTrace failed");
};

tars.TopologyProxy.prototype.listTrace = function (date, serverName) {
    var version = this._worker.version;
    if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
        return this._worker.tup_invoke("listTrace", __tars_Topology$listTrace$PE(date, serverName, version), arguments[arguments.length - 1], __tars_Topology$listTrace$IF).then(__tars_Topology$listTrace$PD, __tars_Topology$listTrace$ER);
    } else {
        return this._worker.tars_invoke("listTrace", __tars_Topology$listTrace$IE(date, serverName), arguments[arguments.length - 1], __tars_Topology$listTrace$IF).then(__tars_Topology$listTrace$ID, __tars_Topology$listTrace$ER);
    }
};
tars.TopologyProxy.listTrace = __tars_Topology$listTrace$IF;

var __tars_Topology$listTraceSummary$IF = {
    "name" : "listTraceSummary",
    "return" : "int32",
    "arguments" : [{
        "name" : "date",
        "class" : "string",
        "direction" : "in"
    }, {
        "name" : "beginTime",
        "class" : "int64",
        "direction" : "in"
    }, {
        "name" : "endTime",
        "class" : "int64",
        "direction" : "in"
    }, {
        "name" : "serverName",
        "class" : "string",
        "direction" : "in"
    }, {
        "name" : "ts",
        "class" : "list(tars.Summary)",
        "direction" : "out"
    }]
};

var __tars_Topology$listTraceSummary$IE = function (date, beginTime, endTime, serverName) {
    var os = new TarsStream.TarsOutputStream();
    os.writeString(1, date);
    os.writeInt64(2, beginTime);
    os.writeInt64(3, endTime);
    os.writeString(4, serverName);
    return os.getBinBuffer();
};

var __tars_Topology$listTraceSummary$ID = function (data) {
    try {
        var is = new TarsStream.TarsInputStream(data.response.sBuffer);
        return {
            "request" : data.request,
            "response" : {
                "costtime" : data.request.costtime,
                "return" : is.readInt32(0, true, 0),
                "arguments" : {
                    "ts" : is.readList(5, true, TarsStream.List(tars.Summary))
                }
            }
        };
    } catch (e) {
        throw _makeError(data, e.message, TarsError.CLIENT.DECODE_ERROR);
    }
};

var __tars_Topology$listTraceSummary$PE = function (date, beginTime, endTime, serverName, __$PROTOCOL$VERSION) {
    var tup = new TarsStream.UniAttribute();
    tup.tupVersion = __$PROTOCOL$VERSION;
    tup.writeString("date", date);
    tup.writeInt64("beginTime", beginTime);
    tup.writeInt64("endTime", endTime);
    tup.writeString("serverName", serverName);
    return tup;
};

var __tars_Topology$listTraceSummary$PD = function (data) {
    try {
        var tup = data.response.tup;
        return {
            "request" : data.request,
            "response" : {
                "costtime" : data.request.costtime,
                "return" : tup.readInt32("", 0),
                "arguments" : {
                    "ts" : tup.readList("ts", TarsStream.List(tars.Summary))
                }
            }
        };
    } catch (e) {
        throw _makeError(data, e.message, TarsError.CLIENT.DECODE_ERROR);
    }
};

var __tars_Topology$listTraceSummary$ER = function (data) {
    throw _makeError(data, "Call Topology::listTraceSummary failed");
};

tars.TopologyProxy.prototype.listTraceSummary = function (date, beginTime, endTime, serverName) {
    var version = this._worker.version;
    if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
        return this._worker.tup_invoke("listTraceSummary", __tars_Topology$listTraceSummary$PE(date, beginTime, endTime, serverName, version), arguments[arguments.length - 1], __tars_Topology$listTraceSummary$IF).then(__tars_Topology$listTraceSummary$PD, __tars_Topology$listTraceSummary$ER);
    } else {
        return this._worker.tars_invoke("listTraceSummary", __tars_Topology$listTraceSummary$IE(date, beginTime, endTime, serverName), arguments[arguments.length - 1], __tars_Topology$listTraceSummary$IF).then(__tars_Topology$listTraceSummary$ID, __tars_Topology$listTraceSummary$ER);
    }
};
tars.TopologyProxy.listTraceSummary = __tars_Topology$listTraceSummary$IF;



